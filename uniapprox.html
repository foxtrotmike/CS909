<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Universal Approximation + Depth Demo (TensorFlow.js)</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; color:#111; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    h2 { font-size: 14px; margin: 0 0 10px; }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; }
    .col { display:flex; flex-direction:column; gap:14px; }
    .card { border:1px solid #ddd; border-radius:12px; padding:12px; background:#fff; }
    .controls { width: 390px; }
    label { display:block; margin:10px 0 4px; font-size: 13px; }
    select, input[type="number"] { width:100%; padding:6px 8px; border-radius:10px; border:1px solid #ccc; background:#fff; }
    input[type="range"] { width:100%; }
    .btnrow { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button { padding:8px 10px; border-radius:10px; border:1px solid #bbb; background:#f7f7f7; cursor:pointer; }
    button:active { transform: translateY(1px); }
    canvas { border:1px solid #eee; border-radius:12px; background:#fff; }
    .small { font-size: 12px; color:#333; line-height: 1.35; }
    .stat { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; white-space: pre; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; background:#fafafa; }
    .sep { height:1px; background:#eee; margin:10px 0; }
    .two { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .warn { color:#8a3b00; }
  </style>
</head>
<body>
  <h1>Neural Networks as Universal Approximators: Basis View and Depth Comparison (TensorFlow.js)</h1>

  <div class="row">
    <!-- ---------------- Part 1 ---------------- -->
    <div class="card controls">
      <h2>Part 1: Square wave (and other waves) with 1 hidden layer, P sigmoids</h2>
      <div class="small">
        Model: <span class="pill">ŷ(x) = Σᵢ vᵢ σ(wᵢ x + bᵢ) + v₀</span><br/>
        We plot (1) target vs approximation and (2) each term <b>vᵢ σ(wᵢ x + bᵢ)</b> across x, plus the bias <b>v₀</b>.
      </div>

      <label>Wave to approximate</label>
      <select id="p1Target">
        <option value="square">Square wave via Fourier odd terms</option>
        <option value="saw">Sawtooth via Fourier terms</option>
        <option value="triangle">Triangle wave via Fourier odd terms</option>
        <option value="sincos">sin(4x) + cos(10x)</option>
        <option value="gaussmix">Gaussian bumps (mixture)</option>
        <option value="step">Smoothed step (tanh)</option>
      </select>

      <div class="two">
        <div>
          <label>Domain</label>
          <select id="p1Domain">
            <option value="minus1to1">x ∈ [-1, 1]</option>
            <option value="0to1">x ∈ [0, 1]</option>
          </select>
        </div>
        <div>
          <label>Samples (N): <span id="p1NLab"></span></label>
          <input id="p1N" type="range" min="20" max="300" step="1" value="80"/>
        </div>
      </div>

      <div class="two">
        <div>
          <label>Hidden neurons (P): <span id="p1PLab"></span></label>
          <input id="p1P" type="range" min="1" max="80" step="1" value="6"/>
        </div>
        <div>
          <label>Fourier terms (K): <span id="p1KLab"></span></label>
          <input id="p1K" type="range" min="1" max="25" step="1" value="5"/>
        </div>
      </div>

      <div class="two">
        <div>
          <label>Learning rate: <span id="p1LRLab"></span></label>
          <input id="p1LR" type="range" min="-4" max="-0.3" step="0.05" value="-1"/>
        </div>
        <div>
          <label>Epochs per step: <span id="p1EpsLab"></span></label>
          <input id="p1Eps" type="range" min="1" max="300" step="1" value="30"/>
        </div>
      </div>

      <div class="two">
        <div>
          <label>Weight decay (L2): <span id="p1WDLab"></span></label>
          <input id="p1WD" type="range" min="0" max="0.1" step="0.005" value="0"/>
        </div>
        <div>
          <label>Initialiser</label>
          <select id="p1Init">
            <option value="xavier">Xavier (glorotNormal)</option>
            <option value="small">Small normal</option>
            <option value="zeros">Near-zero (slow start)</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="p1InitBtn">Initialise</button>
        <button id="p1StartBtn">Start</button>
        <button id="p1StopBtn">Stop</button>
        <button id="p1StepBtn">Step</button>
        <button id="p1ResetLossBtn">Reset loss</button>
      </div>

      <div class="sep"></div>

      <div class="small warn" id="p1Note"></div>
      <div class="stat" id="p1Stats">not initialised</div>
    </div>

    <div class="col">
      <div class="card">
        <div class="small"><b>Part 1 Fit:</b> target (dots) vs approximation (red)</div>
        <canvas id="p1Fit" width="760" height="260"></canvas>
      </div>
      <div class="card">
        <div class="small"><b>Part 1 Basis:</b> bias v₀ (thick black) and each vᵢ σ(wᵢ x + bᵢ)</div>
        <canvas id="p1Basis" width="760" height="260"></canvas>
      </div>
      <div class="card">
        <div class="small"><b>Part 1 Loss:</b> log10(MSE) over steps</div>
        <canvas id="p1Loss" width="760" height="220"></canvas>
      </div>
    </div>

    <!-- ---------------- Part 2 ---------------- -->
    <div class="card controls">
      <h2>Part 2: Shallow vs deep on sin(x)·sin(4x) (and other functions)</h2>
      <div class="small">
        We train <b>two models</b> in parallel on the same data and plot both approximations.<br/>
        Default deep: <span class="pill">1 → 32 → 8 → 1</span>, shallow: <span class="pill">1 → H → 1</span>.
      </div>

      <label>Function to approximate (Part 2)</label>
      <select id="p2Target">
        <option value="sinprod">sin(x) · sin(4x)</option>
        <option value="sincos">sin(4x) + cos(10x)</option>
        <option value="square">Square wave via Fourier odd terms</option>
        <option value="triangle">Triangle wave via Fourier odd terms</option>
        <option value="gaussmix">Gaussian bumps (mixture)</option>
      </select>

      <div class="two">
        <div>
          <label>Domain</label>
          <select id="p2Domain">
            <option value="0to2pi">x ∈ [0, 2π]</option>
            <option value="minus1to1">x ∈ [-1, 1]</option>
          </select>
        </div>
        <div>
          <label>Samples (N): <span id="p2NLab"></span></label>
          <input id="p2N" type="range" min="20" max="400" step="1" value="100"/>
        </div>
      </div>

      <label>Shallow hidden size H: <span id="p2HLab"></span></label>
      <input id="p2H" type="range" min="2" max="256" step="1" value="128"/>

      <div class="two">
        <div>
          <label>Deep width 1 (W1): <span id="p2W1Lab"></span></label>
          <input id="p2W1" type="range" min="2" max="128" step="1" value="32"/>
        </div>
        <div>
          <label>Deep width 2 (W2): <span id="p2W2Lab"></span></label>
          <input id="p2W2" type="range" min="2" max="64" step="1" value="8"/>
        </div>
      </div>

      <div class="two">
        <div>
          <label>Fourier terms (K): <span id="p2KLab"></span></label>
          <input id="p2K" type="range" min="1" max="25" step="1" value="5"/>
        </div>
        <div>
          <label>Activation</label>
          <select id="p2Act">
            <option value="sigmoid">sigmoid</option>
            <option value="tanh">tanh</option>
            <option value="relu">relu</option>
          </select>
        </div>
      </div>

      <div class="two">
        <div>
          <label>Learning rate: <span id="p2LRLab"></span></label>
          <input id="p2LR" type="range" min="-4" max="-0.3" step="0.05" value="-2"/>
        </div>
        <div>
          <label>Epochs per step: <span id="p2EpsLab"></span></label>
          <input id="p2Eps" type="range" min="1" max="300" step="1" value="50"/>
        </div>
      </div>

      <div class="two">
        <div>
          <label>Weight decay (L2): <span id="p2WDLab"></span></label>
          <input id="p2WD" type="range" min="0" max="0.1" step="0.005" value="0"/>
        </div>
        <div>
          <label>Match parameter counts?</label>
          <select id="p2Match">
            <option value="off">Off (manual sizes)</option>
            <option value="on">On (auto-set shallow H)</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="p2InitBtn">Initialise</button>
        <button id="p2StartBtn">Start</button>
        <button id="p2StopBtn">Stop</button>
        <button id="p2StepBtn">Step</button>
        <button id="p2ResetLossBtn">Reset loss</button>
      </div>

      <div class="sep"></div>
      <div class="stat" id="p2Stats">not initialised</div>
    </div>

    <div class="col">
      <div class="card">
        <div class="small"><b>Part 2 Fit:</b> target (black) vs shallow (blue) vs deep (red)</div>
        <canvas id="p2Fit" width="760" height="280"></canvas>
      </div>
      <div class="card">
        <div class="small"><b>Part 2 Loss:</b> log10(MSE) for shallow (blue) and deep (red)</div>
        <canvas id="p2Loss" width="760" height="220"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // -----------------------------
  // Plot helpers
  // -----------------------------
  function clear(ctx, w, h) { ctx.clearRect(0, 0, w, h); }

  function niceBounds(arr, padFrac=0.08) {
    let mn = Infinity, mx = -Infinity;
    for (const v of arr) { if (v < mn) mn = v; if (v > mx) mx = v; }
    if (!isFinite(mn) || !isFinite(mx)) return [-1, 1];
    if (mn === mx) return [mn - 1, mx + 1];
    const pad = (mx - mn) * padFrac;
    return [mn - pad, mx + pad];
  }

  function drawAxes(ctx, w, h, xMin, xMax, yMin, yMax, pad=34) {
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#aaa";
    ctx.fillStyle = "#444";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

    ctx.strokeRect(pad, pad, w - 2*pad, h - 2*pad);

    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const tx = pad + (w - 2*pad) * (i / ticks);
      const xv = xMin + (xMax - xMin) * (i / ticks);
      ctx.beginPath(); ctx.moveTo(tx, h - pad); ctx.lineTo(tx, h - pad + 5); ctx.stroke();
      ctx.fillText(xv.toFixed(2), tx - 16, h - pad + 18);
    }
    for (let i = 0; i <= ticks; i++) {
      const ty = pad + (h - 2*pad) * (i / ticks);
      const yv = yMax - (yMax - yMin) * (i / ticks);
      ctx.beginPath(); ctx.moveTo(pad - 5, ty); ctx.lineTo(pad, ty); ctx.stroke();
      ctx.fillText(yv.toFixed(2), 4, ty + 4);
    }
    ctx.restore();
  }

  function toCanvasXY(x, y, w, h, xMin, xMax, yMin, yMax, pad=34) {
    const cx = pad + (w - 2*pad) * ((x - xMin) / (xMax - xMin));
    const cy = pad + (h - 2*pad) * (1 - (y - yMin) / (yMax - yMin));
    return [cx, cy];
  }

  function drawPolyline(ctx, xs, ys, w, h, xMin, xMax, yMin, yMax, strokeStyle="#111", lineWidth=2, pad=34) {
    if (xs.length === 0) return;
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    const [x0, y0] = toCanvasXY(xs[0], ys[0], w, h, xMin, xMax, yMin, yMax, pad);
    ctx.moveTo(x0, y0);
    for (let i = 1; i < xs.length; i++) {
      const [cx, cy] = toCanvasXY(xs[i], ys[i], w, h, xMin, xMax, yMin, yMax, pad);
      ctx.lineTo(cx, cy);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawDots(ctx, xs, ys, w, h, xMin, xMax, yMin, yMax, fillStyle="#111", r=3, pad=34) {
    ctx.save();
    ctx.fillStyle = fillStyle;
    for (let i = 0; i < xs.length; i++) {
      const [cx, cy] = toCanvasXY(xs[i], ys[i], w, h, xMin, xMax, yMin, yMax, pad);
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2*Math.PI); ctx.fill();
    }
    ctx.restore();
  }

  // -----------------------------
  // Target functions
  // -----------------------------
  function linspace(a, b, n) {
    const out = [];
    for (let i = 0; i < n; i++) out.push(a + (b - a) * (i / (n - 1)));
    return out;
  }

  function squareFourier(xs, K=5, A=1.0, T=1.0) {
    const ys = new Array(xs.length).fill(0);
    const maxOdd = 2*K - 1;
    for (let n = 1; n <= maxOdd; n += 2) {
      const coef = (4*A/Math.PI) / n;
      for (let i = 0; i < xs.length; i++) ys[i] += coef * Math.sin(2*Math.PI*n*xs[i]/T);
    }
    return ys;
  }

  function sawFourier(xs, K=10, A=1.0, T=1.0) {
    // A simple sawtooth series on [0,T]: f(x) ≈ (2A/π) Σ_{n=1..K} (-1)^{n+1} sin(2π n x/T)/n
    const ys = new Array(xs.length).fill(0);
    for (let n = 1; n <= K; n++) {
      const sign = (n % 2 === 1) ? 1 : -1;
      const coef = (2*A/Math.PI) * sign / n;
      for (let i = 0; i < xs.length; i++) ys[i] += coef * Math.sin(2*Math.PI*n*xs[i]/T);
    }
    return ys;
  }

  function triangleFourier(xs, K=5, A=1.0, T=1.0) {
    // Triangle series: (8A/π^2) Σ_{n odd} (-1)^{(n-1)/2} sin(2π n x/T)/n^2
    const ys = new Array(xs.length).fill(0);
    const maxOdd = 2*K - 1;
    for (let n = 1; n <= maxOdd; n += 2) {
      const k = (n - 1) / 2;
      const sign = (k % 2 === 0) ? 1 : -1;
      const coef = (8*A/(Math.PI*Math.PI)) * sign / (n*n);
      for (let i = 0; i < xs.length; i++) ys[i] += coef * Math.sin(2*Math.PI*n*xs[i]/T);
    }
    return ys;
  }

  function sincos(xs) { return xs.map(x => Math.sin(4*x) + Math.cos(10*x)); }
  function sinprod(xs) { return xs.map(x => Math.sin(x) * Math.sin(4*x)); }

  function gaussMix(xs) {
    // A fixed mixture: good for showing smooth bumps
    const centres = [-0.6, -0.1, 0.3, 0.75];
    const widths  = [ 0.10, 0.18, 0.12, 0.22];
    const amps    = [ 1.00, -0.7, 0.90, -0.5];
    const ys = [];
    for (const x of xs) {
      let s = 0;
      for (let i = 0; i < centres.length; i++) {
        const d = (x - centres[i]) / widths[i];
        s += amps[i] * Math.exp(-0.5 * d * d);
      }
      ys.push(s);
    }
    return ys;
  }

  function smoothStep(xs) {
    // Step-like function, still continuous
    return xs.map(x => Math.tanh(6 * (x - 0.1)));
  }

  function buildTarget(xs, which, K, domain) {
    // For Fourier waves we interpret xs as spanning [0,1] or [-1,1].
    // We map to [0,1] for Fourier formulae (period T=1).
    if (which === "square" || which === "saw" || which === "triangle") {
      const t = xs.map(x => {
        if (domain === "minus1to1") return (x + 1) / 2;
        return x; // assume [0,1]
      });
      if (which === "square") return squareFourier(t, K, 1.0, 1.0);
      if (which === "saw") return sawFourier(t, K, 1.0, 1.0);
      return triangleFourier(t, K, 1.0, 1.0);
    }
    if (which === "sincos") return sincos(xs);
    if (which === "sinprod") return sinprod(xs);
    if (which === "gaussmix") return gaussMix(xs);
    return smoothStep(xs);
  }

  // -----------------------------
  // Part 1: Shallow model + basis
  // -----------------------------
  const p1 = {
    model: null,
    opt: null,
    xArr: [],
    yArr: [],
    xT: null,
    yT: null,
    running: false,
    epoch: 0,
    lossHist: [],
    lossMax: 900
  };

  function p1DisposeTensors() {
    if (p1.xT) p1.xT.dispose();
    if (p1.yT) p1.yT.dispose();
    p1.xT = null; p1.yT = null;
  }

  function p1BuildData() {
    p1DisposeTensors();
    const N = parseInt(el("p1N").value, 10);
    const domain = el("p1Domain").value;
    const xs = (domain === "minus1to1") ? linspace(-1, 1, N) : linspace(0, 1, N);
    const which = el("p1Target").value;
    const K = parseInt(el("p1K").value, 10);

    p1.xArr = xs;
    p1.yArr = buildTarget(xs, which, K, domain);

    p1.xT = tf.tensor2d(p1.xArr, [p1.xArr.length, 1], "float32");
    p1.yT = tf.tensor2d(p1.yArr, [p1.yArr.length, 1], "float32");
  }

  function p1InitKernelBias(units) {
    const mode = el("p1Init").value;
    if (mode === "xavier") {
      return {
        kernelInit: "glorotNormal",
        biasInit: "zeros"
      };
    }
    if (mode === "small") {
      return {
        kernelInit: tf.initializers.randomNormal({mean:0, stddev:0.2}),
        biasInit: tf.initializers.randomNormal({mean:0, stddev:0.2})
      };
    }
    // near-zero
    return {
      kernelInit: tf.initializers.randomNormal({mean:0, stddev:0.02}),
      biasInit: tf.initializers.randomNormal({mean:0, stddev:0.02})
    };
  }

  function p1BuildModel() {
    if (p1.model) p1.model.dispose();
    const P = parseInt(el("p1P").value, 10);

    const inits = p1InitKernelBias(P);

    p1.model = tf.sequential();
    p1.model.add(tf.layers.dense({
      inputShape: [1],
      units: P,
      activation: "sigmoid",
      kernelInitializer: inits.kernelInit,
      biasInitializer: inits.biasInit
    }));
    p1.model.add(tf.layers.dense({
      units: 1,
      activation: "linear",
      kernelInitializer: inits.kernelInit,
      biasInitializer: inits.biasInit
    }));

    const lrExp = parseFloat(el("p1LR").value);
    const lr = Math.pow(10, lrExp);
    p1.opt = tf.train.adam(lr);

    p1.epoch = 0;
  }

  function msePlusWD(model, pred, yTrue, wd) {
    return tf.tidy(() => {
      const mse = tf.mean(tf.square(tf.sub(pred, yTrue)));
      if (wd <= 0) return mse;
      let reg = tf.scalar(0);
      for (const w of model.trainableWeights) {
        const isBias = w.name.toLowerCase().includes("bias");
        if (!isBias) reg = tf.add(reg, tf.sum(tf.square(w.read())));
      }
      return tf.add(mse, tf.mul(tf.scalar(wd), reg));
    });
  }

  async function p1TrainSteps(steps) {
    const wd = parseFloat(el("p1WD").value);
    for (let s = 0; s < steps; s++) {
      const lossVal = await p1.opt.minimize(() => {
        const pred = p1.model.predict(p1.xT);
        return msePlusWD(p1.model, pred, p1.yT, wd);
      }, true).data();

      p1.lossHist.push(lossVal[0]);
      if (p1.lossHist.length > p1.lossMax) p1.lossHist.shift();
      p1.epoch += 1;

      if ((s % 25) === 0) await tf.nextFrame();
    }
  }

  async function p1Predict() {
    const yPredT = tf.tidy(() => p1.model.predict(p1.xT));
    const yPred = await yPredT.data();
    yPredT.dispose();
    return Array.from(yPred);
  }

  function p1GetParams() {
    const [dense1, dense2] = p1.model.layers;
    const [W1, b1] = dense1.getWeights(); // W1 [1,P], b1 [P]
    const [W2, b2] = dense2.getWeights(); // W2 [P,1], b2 [1]
    return { W1, b1, W2, b2 };
  }

  // Part 1 canvases
  const p1FitC = el("p1Fit"), p1LossC = el("p1Loss"), p1BasisC = el("p1Basis");
  const p1FitX = p1FitC.getContext("2d"), p1LossX = p1LossC.getContext("2d"), p1BasisX = p1BasisC.getContext("2d");

  async function p1DrawFit() {
    clear(p1FitX, p1FitC.width, p1FitC.height);
    if (p1.xArr.length === 0) return;

    const yPred = p1.model ? await p1Predict() : null;
    const yAll = yPred ? p1.yArr.concat(yPred) : p1.yArr.slice();
    const [yMin, yMax] = niceBounds(yAll);
    const xMin = p1.xArr[0], xMax = p1.xArr[p1.xArr.length - 1];

    drawAxes(p1FitX, p1FitC.width, p1FitC.height, xMin, xMax, yMin, yMax);
    drawPolyline(p1FitX, p1.xArr, p1.yArr, p1FitC.width, p1FitC.height, xMin, xMax, yMin, yMax, "#000", 1.6);
    drawDots(p1FitX, p1.xArr, p1.yArr, p1FitC.width, p1FitC.height, xMin, xMax, yMin, yMax, "#000", 2.5);
    if (yPred) drawPolyline(p1FitX, p1.xArr, yPred, p1FitC.width, p1FitC.height, xMin, xMax, yMin, yMax, "#d11", 2.4);

    p1FitX.save();
    p1FitX.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    p1FitX.fillStyle = "#000"; p1FitX.fillText("Target", 44, 18);
    p1FitX.fillStyle = "#d11"; p1FitX.fillText("Approx", 110, 18);
    p1FitX.restore();
  }

  function p1DrawLoss() {
    clear(p1LossX, p1LossC.width, p1LossC.height);
    if (p1.lossHist.length === 0) {
      p1LossX.save();
      p1LossX.fillStyle = "#444";
      p1LossX.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      p1LossX.fillText("No loss yet. Click Start or Step.", 18, 22);
      p1LossX.restore();
      return;
    }
    const xs = [], ys = [];
    for (let i = 0; i < p1.lossHist.length; i++) {
      xs.push(i);
      ys.push(Math.log10(Math.max(p1.lossHist[i], 1e-12)));
    }
    const [yMin, yMax] = niceBounds(ys);
    const xMin = 0, xMax = Math.max(1, xs[xs.length - 1]);

    drawAxes(p1LossX, p1LossC.width, p1LossC.height, xMin, xMax, yMin, yMax);
    drawPolyline(p1LossX, xs, ys, p1LossC.width, p1LossC.height, xMin, xMax, yMin, yMax, "#1a1a1a", 2.0);

    const last = ys[ys.length - 1];
    p1LossX.save();
    p1LossX.fillStyle = "#444";
    p1LossX.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    p1LossX.fillText(`last log10(MSE): ${last.toFixed(3)}`, 44, 18);
    p1LossX.restore();
  }

  async function p1DrawBasis() {
    clear(p1BasisX, p1BasisC.width, p1BasisC.height);
    if (!p1.model) {
      p1BasisX.save();
      p1BasisX.fillStyle = "#444";
      p1BasisX.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      p1BasisX.fillText("Not initialised.", 18, 22);
      p1BasisX.restore();
      return;
    }

    const { W1, b1, W2, b2 } = p1GetParams();
    const P = b1.shape[0];

    const { cArr, v0Val } = await tf.tidy(async () => {
      const w = W1.squeeze();     // [P]
      const b = b1;              // [P]
      const v = W2.squeeze();     // [P]
      const v0 = b2.squeeze();    // scalar
      const x = p1.xT.squeeze();  // [N]
      const xCol = x.reshape([-1, 1]);
      const wRow = w.reshape([1, -1]);
      const bRow = b.reshape([1, -1]);
      const z = tf.sigmoid(tf.add(tf.mul(xCol, wRow), bRow)); // [N,P]
      const vRow = v.reshape([1, -1]);
      const c = tf.mul(z, vRow); // [N,P]
      const cArr = await c.array();
      const v0Val = (await v0.data())[0];
      return { cArr, v0Val };
    });

    W1.dispose(); b1.dispose(); W2.dispose(); b2.dispose();

    const all = [];
    for (let i = 0; i < cArr.length; i++) {
      all.push(v0Val);
      for (let j = 0; j < P; j++) all.push(cArr[i][j]);
    }
    const [yMin, yMax] = niceBounds(all);
    const xMin = p1.xArr[0], xMax = p1.xArr[p1.xArr.length - 1];
    drawAxes(p1BasisX, p1BasisC.width, p1BasisC.height, xMin, xMax, yMin, yMax);

    const biasLine = p1.xArr.map(() => v0Val);
    drawPolyline(p1BasisX, p1.xArr, biasLine, p1BasisC.width, p1BasisC.height, xMin, xMax, yMin, yMax, "#000", 2.4);

    for (let j = 0; j < P; j++) {
      const ys = cArr.map(row => row[j]);
      const g = 35 + Math.floor(190 * (j / Math.max(1, P - 1)));
      const col = `rgb(${g},${g},${g})`;
      drawPolyline(p1BasisX, p1.xArr, ys, p1BasisC.width, p1BasisC.height, xMin, xMax, yMin, yMax, col, 1.5);
    }

    p1BasisX.save();
    p1BasisX.fillStyle = "#444";
    p1BasisX.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    p1BasisX.fillText(`v₀ is thick black. Each grey curve is vᵢ σ(wᵢ x + bᵢ). P=${P}`, 44, 18);
    p1BasisX.restore();
  }

  function p1UpdateStats() {
    const lrExp = parseFloat(el("p1LR").value);
    const lr = Math.pow(10, lrExp);
    const P = parseInt(el("p1P").value, 10);
    const wd = parseFloat(el("p1WD").value);
    const which = el("p1Target").value;
    const domain = el("p1Domain").value;
    const K = parseInt(el("p1K").value, 10);
    const paramCount = p1.model ? p1.model.countParams() : 0;
    const lastLoss = p1.lossHist.length ? p1.lossHist[p1.lossHist.length - 1] : NaN;
    const lastLog = isFinite(lastLoss) ? Math.log10(Math.max(lastLoss, 1e-12)) : NaN;

    el("p1Stats").textContent =
`epoch: ${p1.epoch}
target: ${which}    domain: ${domain}    K: ${K}
P: ${P}    params: ${paramCount}
learning rate: ${lr.toExponential(2)}    weight decay: ${wd.toFixed(4)}
last MSE: ${isFinite(lastLoss) ? lastLoss.toExponential(3) : "n/a"}
last log10(MSE): ${isFinite(lastLog) ? lastLog.toFixed(3) : "n/a"}`;
  }

  async function p1DrawAll() {
    await p1DrawFit();
    await p1DrawBasis();
    p1DrawLoss();
    p1UpdateStats();

    // Gentle note for discontinuous targets
    const which = el("p1Target").value;
    const note = (which === "square" || which === "saw")
      ? "Note: discontinuities typically produce ringing near the jump (Gibbs-like behaviour). Increase P and/or add weight decay to see trade-offs."
      : "";
    el("p1Note").textContent = note;
  }

  async function p1Initialise() {
    p1.running = false;
    p1BuildData();
    p1BuildModel();
    p1.lossHist = [];
    await p1DrawAll();
  }

  async function p1Step() {
    if (!p1.model) return;
    const eps = parseInt(el("p1Eps").value, 10);
    await p1TrainSteps(eps);
    await p1DrawAll();
  }

  async function p1Loop() {
    if (!p1.running) return;
    await p1Step();
    requestAnimationFrame(p1Loop);
  }

  // -----------------------------
  // Part 2: shallow vs deep
  // -----------------------------
  const p2 = {
    shallow: null,
    deep: null,
    optS: null,
    optD: null,
    xArr: [],
    yArr: [],
    xT: null,
    yT: null,
    running: false,
    epoch: 0,
    lossS: [],
    lossD: [],
    lossMax: 900
  };

  function p2DisposeTensors() {
    if (p2.xT) p2.xT.dispose();
    if (p2.yT) p2.yT.dispose();
    p2.xT = null; p2.yT = null;
  }

  function p2BuildData() {
    p2DisposeTensors();
    const N = parseInt(el("p2N").value, 10);
    const domain = el("p2Domain").value;
    let xs;
    if (domain === "0to2pi") xs = linspace(0, 2*Math.PI, N);
    else xs = linspace(-1, 1, N);

    const which = el("p2Target").value;
    const K = parseInt(el("p2K").value, 10);

    // For Fourier targets in Part 2, map to [0,1] if needed
    let y;
    if (which === "square" || which === "triangle") {
      const t = (domain === "0to2pi")
        ? xs.map(x => x / (2*Math.PI))
        : xs.map(x => (x + 1) / 2);
      if (which === "square") y = squareFourier(t, K, 1.0, 1.0);
      else y = triangleFourier(t, K, 1.0, 1.0);
    } else if (which === "sincos") y = sincos(xs);
    else if (which === "gaussmix") y = gaussMix(domain === "0to2pi" ? xs.map(x => (x/Math.PI)-1) : xs);
    else y = sinprod(xs);

    p2.xArr = xs;
    p2.yArr = y;

    p2.xT = tf.tensor2d(p2.xArr, [p2.xArr.length, 1], "float32");
    p2.yT = tf.tensor2d(p2.yArr, [p2.yArr.length, 1], "float32");
  }

  function makeActivationLayer(act) {
    if (act === "tanh") return tf.layers.activation({activation: "tanh"});
    if (act === "relu") return tf.layers.activation({activation: "relu"});
    return tf.layers.activation({activation: "sigmoid"});
  }

  function p2CountParamsForDeep(W1, W2) {
    // Deep: 1->W1, W1->W2, W2->1, with biases
    // (1*W1 + W1) + (W1*W2 + W2) + (W2*1 + 1)
    return (1*W1 + W1) + (W1*W2 + W2) + (W2*1 + 1);
  }

  function p2AutoMatchShallow() {
    const match = el("p2Match").value;
    if (match !== "on") return;

    const W1 = parseInt(el("p2W1").value, 10);
    const W2 = parseInt(el("p2W2").value, 10);
    const deepParams = p2CountParamsForDeep(W1, W2);

    // Shallow: 1->H->1: (1*H + H) + (H*1 + 1) = 3H + 1
    // Solve H ≈ (deepParams - 1)/3
    const H = Math.max(2, Math.round((deepParams - 1) / 3));
    el("p2H").value = String(Math.min(256, H));
  }

  function p2BuildModels() {
    if (p2.shallow) p2.shallow.dispose();
    if (p2.deep) p2.deep.dispose();

    const act = el("p2Act").value;
    const H = parseInt(el("p2H").value, 10);
    const W1 = parseInt(el("p2W1").value, 10);
    const W2 = parseInt(el("p2W2").value, 10);

    // Shallow: 1 -> H -> 1
    p2.shallow = tf.sequential();
    p2.shallow.add(tf.layers.dense({ inputShape:[1], units:H }));
    p2.shallow.add(makeActivationLayer(act));
    p2.shallow.add(tf.layers.dense({ units:1 }));

    // Deep: 1 -> W1 -> W2 -> 1
    p2.deep = tf.sequential();
    p2.deep.add(tf.layers.dense({ inputShape:[1], units:W1 }));
    p2.deep.add(makeActivationLayer(act));
    p2.deep.add(tf.layers.dense({ units:W2 }));
    p2.deep.add(makeActivationLayer(act));
    p2.deep.add(tf.layers.dense({ units:1 }));

    const lrExp = parseFloat(el("p2LR").value);
    const lr = Math.pow(10, lrExp);
    p2.optS = tf.train.adam(lr);
    p2.optD = tf.train.adam(lr);

    p2.epoch = 0;
  }

  async function p2TrainSteps(steps) {
    const wd = parseFloat(el("p2WD").value);
    for (let s = 0; s < steps; s++) {
      const lossS = await p2.optS.minimize(() => {
        const pred = p2.shallow.predict(p2.xT);
        return msePlusWD(p2.shallow, pred, p2.yT, wd);
      }, true).data();
      const lossD = await p2.optD.minimize(() => {
        const pred = p2.deep.predict(p2.xT);
        return msePlusWD(p2.deep, pred, p2.yT, wd);
      }, true).data();

      p2.lossS.push(lossS[0]); if (p2.lossS.length > p2.lossMax) p2.lossS.shift();
      p2.lossD.push(lossD[0]); if (p2.lossD.length > p2.lossMax) p2.lossD.shift();

      p2.epoch += 1;
      if ((s % 25) === 0) await tf.nextFrame();
    }
  }

  async function p2Predict(model) {
    const yPredT = tf.tidy(() => model.predict(p2.xT));
    const yPred = await yPredT.data();
    yPredT.dispose();
    return Array.from(yPred);
  }

  const p2FitC = el("p2Fit"), p2LossC = el("p2Loss");
  const p2FitX = p2FitC.getContext("2d"), p2LossX = p2LossC.getContext("2d");

  async function p2DrawFit() {
    clear(p2FitX, p2FitC.width, p2FitC.height);
    if (p2.xArr.length === 0) return;

    const yS = (p2.shallow) ? await p2Predict(p2.shallow) : null;
    const yD = (p2.deep) ? await p2Predict(p2.deep) : null;

    const all = p2.yArr.concat(yS || []).concat(yD || []);
    const [yMin, yMax] = niceBounds(all);
    const xMin = p2.xArr[0], xMax = p2.xArr[p2.xArr.length - 1];

    drawAxes(p2FitX, p2FitC.width, p2FitC.height, xMin, xMax, yMin, yMax);

    drawPolyline(p2FitX, p2.xArr, p2.yArr, p2FitC.width, p2FitC.height, xMin, xMax, yMin, yMax, "#000", 2.0);
    if (yS) drawPolyline(p2FitX, p2.xArr, yS, p2FitC.width, p2FitC.height, xMin, xMax, yMin, yMax, "#1463ff", 2.2);
    if (yD) drawPolyline(p2FitX, p2.xArr, yD, p2FitC.width, p2FitC.height, xMin, xMax, yMin, yMax, "#d11", 2.2);

    p2FitX.save();
    p2FitX.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    p2FitX.fillStyle = "#000"; p2FitX.fillText("Target", 44, 18);
    p2FitX.fillStyle = "#1463ff"; p2FitX.fillText("Shallow", 110, 18);
    p2FitX.fillStyle = "#d11"; p2FitX.fillText("Deep", 180, 18);
    p2FitX.restore();
  }

  function p2DrawLoss() {
    clear(p2LossX, p2LossC.width, p2LossC.height);
    if (p2.lossS.length === 0 || p2.lossD.length === 0) {
      p2LossX.save();
      p2LossX.fillStyle = "#444";
      p2LossX.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      p2LossX.fillText("No loss yet. Click Start or Step.", 18, 22);
      p2LossX.restore();
      return;
    }

    const xs = [];
    const ysS = [];
    const ysD = [];
    const L = Math.min(p2.lossS.length, p2.lossD.length);
    for (let i = 0; i < L; i++) {
      xs.push(i);
      ysS.push(Math.log10(Math.max(p2.lossS[i], 1e-12)));
      ysD.push(Math.log10(Math.max(p2.lossD[i], 1e-12)));
    }
    const [yMin, yMax] = niceBounds(ysS.concat(ysD));
    const xMin = 0, xMax = Math.max(1, xs[xs.length - 1]);

    drawAxes(p2LossX, p2LossC.width, p2LossC.height, xMin, xMax, yMin, yMax);
    drawPolyline(p2LossX, xs, ysS, p2LossC.width, p2LossC.height, xMin, xMax, yMin, yMax, "#1463ff", 2.0);
    drawPolyline(p2LossX, xs, ysD, p2LossC.width, p2LossC.height, xMin, xMax, yMin, yMax, "#d11", 2.0);

    p2LossX.save();
    p2LossX.fillStyle = "#444";
    p2LossX.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const lastS = ysS[ysS.length - 1], lastD = ysD[ysD.length - 1];
    p2LossX.fillText(`last log10(MSE): shallow=${lastS.toFixed(3)}  deep=${lastD.toFixed(3)}`, 44, 18);
    p2LossX.restore();
  }

  function p2UpdateStats() {
    const lrExp = parseFloat(el("p2LR").value);
    const lr = Math.pow(10, lrExp);
    const wd = parseFloat(el("p2WD").value);
    const which = el("p2Target").value;
    const domain = el("p2Domain").value;
    const K = parseInt(el("p2K").value, 10);
    const act = el("p2Act").value;

    const H = parseInt(el("p2H").value, 10);
    const W1 = parseInt(el("p2W1").value, 10);
    const W2 = parseInt(el("p2W2").value, 10);

    const pS = p2.shallow ? p2.shallow.countParams() : 0;
    const pD = p2.deep ? p2.deep.countParams() : 0;

    const lastS = p2.lossS.length ? p2.lossS[p2.lossS.length - 1] : NaN;
    const lastD = p2.lossD.length ? p2.lossD[p2.lossD.length - 1] : NaN;

    el("p2Stats").textContent =
`epoch: ${p2.epoch}
target: ${which}    domain: ${domain}    K: ${K}
activation: ${act}
shallow: 1→${H}→1    params: ${pS}
deep: 1→${W1}→${W2}→1    params: ${pD}
learning rate: ${lr.toExponential(2)}    weight decay: ${wd.toFixed(4)}
last MSE: shallow=${isFinite(lastS)?lastS.toExponential(3):"n/a"}   deep=${isFinite(lastD)?lastD.toExponential(3):"n/a"}`;
  }

  async function p2DrawAll() {
    await p2DrawFit();
    p2DrawLoss();
    p2UpdateStats();
  }

  async function p2Initialise() {
    p2.running = false;
    p2AutoMatchShallow();
    p2BuildData();
    p2BuildModels();
    p2.lossS = [];
    p2.lossD = [];
    await p2DrawAll();
  }

  async function p2Step() {
    if (!p2.shallow || !p2.deep) return;
    const eps = parseInt(el("p2Eps").value, 10);
    await p2TrainSteps(eps);
    await p2DrawAll();
  }

  async function p2Loop() {
    if (!p2.running) return;
    await p2Step();
    requestAnimationFrame(p2Loop);
  }

  // -----------------------------
  // UI glue
  // -----------------------------
  function el(id) { return document.getElementById(id); }

  function syncLabels() {
    el("p1NLab").textContent = el("p1N").value;
    el("p1PLab").textContent = el("p1P").value;
    el("p1KLab").textContent = el("p1K").value;
    el("p1EpsLab").textContent = el("p1Eps").value;
    el("p1WDLab").textContent = Number(el("p1WD").value).toFixed(3);
    const p1lr = Math.pow(10, Number(el("p1LR").value));
    el("p1LRLab").textContent = p1lr.toExponential(2);

    el("p2NLab").textContent = el("p2N").value;
    el("p2HLab").textContent = el("p2H").value;
    el("p2W1Lab").textContent = el("p2W1").value;
    el("p2W2Lab").textContent = el("p2W2").value;
    el("p2KLab").textContent = el("p2K").value;
    el("p2EpsLab").textContent = el("p2Eps").value;
    el("p2WDLab").textContent = Number(el("p2WD").value).toFixed(3);
    const p2lr = Math.pow(10, Number(el("p2LR").value));
    el("p2LRLab").textContent = p2lr.toExponential(2);
  }

  function bindInputs(ids, fn) {
    for (const id of ids) {
      el(id).addEventListener("input", () => { syncLabels(); if (fn) fn(); });
      el(id).addEventListener("change", () => { syncLabels(); if (fn) fn(); });
    }
  }

  // Part 1 controls: changes that require reinit
  bindInputs(["p1Target","p1Domain","p1N","p1P","p1LR","p1K","p1Init"], () => { p1Initialise(); });
  // Part 1 controls that can be applied without reinit
  bindInputs(["p1Eps","p1WD"], null);

  el("p1InitBtn").addEventListener("click", async () => { await p1Initialise(); });
  el("p1StartBtn").addEventListener("click", async () => { if (!p1.model) await p1Initialise(); p1.running = true; requestAnimationFrame(p1Loop); });
  el("p1StopBtn").addEventListener("click", () => { p1.running = false; });
  el("p1StepBtn").addEventListener("click", async () => { if (!p1.model) await p1Initialise(); await p1Step(); });
  el("p1ResetLossBtn").addEventListener("click", async () => { p1.lossHist = []; p1DrawLoss(); p1UpdateStats(); });

  // Part 2 controls: many changes require reinit
  bindInputs(["p2Target","p2Domain","p2N","p2H","p2W1","p2W2","p2K","p2Act","p2LR","p2Match"], () => { p2Initialise(); });
  bindInputs(["p2Eps","p2WD"], null);

  el("p2InitBtn").addEventListener("click", async () => { await p2Initialise(); });
  el("p2StartBtn").addEventListener("click", async () => { if (!p2.shallow) await p2Initialise(); p2.running = true; requestAnimationFrame(p2Loop); });
  el("p2StopBtn").addEventListener("click", () => { p2.running = false; });
  el("p2StepBtn").addEventListener("click", async () => { if (!p2.shallow) await p2Initialise(); await p2Step(); });
  el("p2ResetLossBtn").addEventListener("click", async () => { p2.lossS = []; p2.lossD = []; p2DrawLoss(); p2UpdateStats(); });

  // Initial boot
  syncLabels();
  p1Initialise();
  p2Initialise();

})();
</script>
</body>
</html>